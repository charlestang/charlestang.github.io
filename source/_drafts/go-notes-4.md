---
title: Go 语言学习笔记（四）— 类型系统
tags:
  - Go
id: '1128'
categories:
  - - something-about-daily-work
    - Go
---

Go 语言提供一系列的基本类型：

*   bool
*   string
*   int、int8、int16、int32、int64
*   uint、uint8、uint16、uint32、uint64、uintptr
*   byte // uint8 的别名
*   rune // int32 的别名 代表一个 Unicode 码
*   float32、float64
*   complex64、complex128

有些类型与编译机器的体系结构有关，比如 int，可能是 8 字节，也可能是 4 字节。

## 用户自定义类型

可以使用 `type` 关键字来创建用户自定义类型，可以使用 `struct` 关键字来创建一个结构类型。

```null
type user struct {
   name   string
   email  string
}
```

也可以使用已经存在的类型，包括自定义类型，来创建一个新类型。

```null
type Duration int64
```

这里需要注意的是，一旦定义了新类型，两种类型是不同的，也不能隐式转换。

### 初始化

可以使用 `var` 关键字来声明一个自定义类型的变量，变量会被 0 值初始化。更常见的是使用结构体字面量来初始化结构类型。

```null
bill := user{
    name:  "Bill",
    email: "bill@email.com",
}
// 字段名是可以省略的，那么顺序就很重要
bill := user{"Bill", "bill@email.com"}
```

### 方法

Go 语言通过给用户自定义类型添加方法来支持面向对象。其实，自定义类型的方法，其实就是普通的方法，只是每个方法强制多添加了一个参数，称作“接收者”，这个参数写在方法名前面，更像是一种语法糖。编译器只允许为命名的用户定义的类型声明方法。

```null
type user struct {
    name     string
    email    string
}

func (u user) notity() {
    fmt.Printf("Sending User Email To %s<%s>\n",
        u.name,
        u.email)

func (u *user) changeEmail(email string) {
    u.email = email
}
```

如果一个函数有“接收者”，那么这个函数就被称为“方法”。上面代码的例子，展示了两种类型的接收者：**“值接收者” 和 “指针接收者”**。

在方法的调用层面，两种类型的方法是完全一样的，调用的主体无论本身是一个“值”，还是一个“指针”，都可以直接不加区分的调用两种类型的方法。这是因为编译器会自动对调用的主体进行处理，会自动与方法声明的类型进行转换。

那么两种类型的区别在哪里呢？**如果使用值接收者声明方法，调用时，接收者参数会传入这个值的一个副本，也即在方法内部对这个值的字段进行修改，不会影响到原值**。

如何决定使用“值接收者”还是“指针接收者”，取决于当前新类型的本质，当给这个类型增加或者删除某个值，是要创建一个新值，还是要更新原来的值？如果要创建一个新值，就应该用“值接收者”，否则，就应该用“指针接收者”。这同时也影响了函数参数传递这个类型的方式，是按值传递，还是按指针传递。保持一致非常重要。

这里需要注意，**决定性因素是“类型的本质”，并不是“是否要修改类型的值”这个行为**。无论是“值接收者” 还是 “指针接收者”，修改类型的值都是可以做到的，比如一些天然的引用类型，比如切片、映射、通道、接口之类。

不过，当为了满足某一个接口的时候，需要根据接口的要求来决定。

## 接口

接口是用于定义行为的类型。被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型实现了某个接口声明的一组方法，这个用户定义类型的值，就可以对接口类型的值赋值。

接口类型的值是一个两个字长的数据结构，第一个字包含一个指向内部表（iTable）的指针，第二个指针指向接口类型值存储的实体类型值的地址。

```null
var n notifier
n = user{"Bill"}

// 也可以把指针赋值给接口类型
var n notifier
n = &user{"Bill"}
```

在实体类型实现接口方法的时候，使用指针接收者实现的方法，只能用指针进行调用，但是使用值接收者实现的方法，可以用指针和值进行调用。

这一段的逻辑比较绕，先来看一个“方法集” 的概念，方法集定义了一组关联到给定类型的值或指针的方法。

值

方法接收者

T

(t T)

*T

(t T) 和 (t *T)

规范里描述的方法集

上面的表说明，使用值接收者定义的方法，可以关联到值的方法集和指针的方法集，但是使用指针接收者定义的方法，只能关联到指针的方法集。也就是解释了上面说的，“使用指针接收者实现的方法，只能用指针进行调用”。

## 嵌入类型

Go 语言允许用户扩展或者修改已有类型的行为，从而实现代码的复用。使用的方法就是**嵌入类型**。将已有的类型直接声明在新的结构类型里。嵌入的类型被称为内部类型。

嵌入类型后，内部类型的相关标识符会提升到外部类型上。这样外部类型就“继承”了内部类型的所有标识符。也可以自己添加新的方法和字段，还可以通过声明与内部类型相同的标识符来覆盖内部类型的方法。

```null
// 内部类型定义
type user struct {
    name  string
    email string
}

// 外部类型定义
type admin struct {
    user
    level string
}
```

注意嵌入类型的语法，只要写上嵌入类型的名字就可以了，**和声明字段是不同**的。