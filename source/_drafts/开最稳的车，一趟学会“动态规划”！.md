---
title: 开最稳的车，一趟学会“动态规划”！
tags: []
id: '1040'
categories:
  - - 日　　记
---

不知道兄弟你有没有在 LeetCode 上刷题呢？那么你为什么刷题呢？嘿嘿 …… 你自己心里清楚的原因。不知道你刷题什么感受呢？嘿嘿 …… 我反正被虐得不要不要的，我感受到了人类个体之间智商的差距，被各种套路和脑筋急转弯按在地上不断摩擦得毫无脾气。

打开 LeetCode 的题库，可以看到各种难度的题总共有 2004 道，其中，打上了“动态规划”标签的题目一共 270 道，因为总题库里很多不是算法题，我们保守估计，动态规划的题目，占到在全部的 15% 左右。如果能拿下这个分类，那么差不多搞定了六分之一的题目。

在我自己的学习过程中，我总是觉得摸不着动态规划解法的头绪，每次查看一道题目的题解，就会发现解题人神奇地一下想出了状态转移方程，然后，直接给出了令人乍舌的简洁代码，他们到底怎么做到的呢？好奇之下，我花钱购买了极客时间的《[动态规划面试宝典](http://gk.link/a/10pil)》课程，进行了认真地学习，我不敢说自己掌握得多么好，总算是看到动态规划类的题目，不再那么心慌意乱了。这里，我就根据自己的领悟，撰写了学习笔记，分享给大家。
<!-- more -->
## 基础篇

什么是动态规划？英文版的维基百科是这么说的：

> Dynamic programming is both a **mathematical optimization** method and a **computer programming** method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.
> 
> —— Wikipedia

动态规划是一种“数学的优化方法”，也是“计算机编程方法”。这种方法有着很广泛的应用，从航天工程，到经济学，从运筹学，到基因技术，无不存在动态规划的身影。

这篇笔记要谈及的**动态规划**，特指计算机动态规划算法。就我个人的学习体会，动态规划与其说是一种具体的算法，不如说是**一种思想**，又或是**一种算法设计的“模式”**。当我们发现问题**具有某些特征**的时候，这类问题，我们可以用动态规划的“模式”，来设计算法，使得我们的算法比用一般朴素思想设计的算法，具有**更高的效率**，或者说，**更低的时间复杂度**。

动态规划经常会用来求解最优化类的问题，比如背包问题，最长（公共）子序列问题，最大子数组和/积等等。

### 与“贪心法”的比较

贪心法和动态规划法相比，是**不同**的两种求解思想。如果解决一个问题，有若干个步骤，那么每个步骤就尽可能向目标靠近，最后一个步骤完成，就恰好求得了问题的解，这种策略就是贪心法。

[![](https://sexywp.com/wp-content/uploads/2021/03/greedy-and-dp-1024x548.png)](https://sexywp.com/wp-content/uploads/2021/03/greedy-and-dp.png)

贪心算法与动态规划

而动态规划方法，不同在于，每个规模更小的子问题，都分别求得到目前为止的最优解，下一个稍大规模的子问题的最优解，建立在前一个子问题的最优解的基础上推理得来，最终求得完整问题的最优解。

常用来说明这个道理的例子，是“硬币找零”问题。

### 与“朴素的递归法”比较

递归，让很多人觉得烧脑，殊不知，递归是算法设计里最简单有效的方法。当一个问题非常困难的时候，我们往往率先设计出解决此问题的递归算法，然后才逐步去设计出更为有效的算法。递归，也是一种编程思想，只是被它自己奇怪的名字给耽误了。

其实，递归是与动态规划最为接近的一个设计思想。递归的核心思想是，将一个大的问题，规约成一个规模稍小的问题，该问题的解，只要通过极其简单的步骤，就可以得出最后大问题的解。如果这个方法成立，那么我们可以利用计算机，一直向更小规模去规约该问题，直到变为非常平凡的问题。

递归背后的核心理论支撑，是数学归纳法。假如有一个很困难的问题 f，其规模为 n，那么，这个问题可以分解为规模为 n-1 的同样问题，加上一个简单步骤，而此问题在规模为 1 时，解法又是显而易见的，那么我们就可以设计出该问题的递归解法。

[![](https://sexywp.com/wp-content/uploads/2021/03/recursion-1024x537.png)](https://sexywp.com/wp-content/uploads/2021/03/recursion.png)

递归

常见的用于说明递归的原理的问题，是著名的“汉诺塔问题”。

我们注意到，其实递归的这个过程，和动态规划是非常像的，上面的公式不就和动态规划的状态转移方程十分类似了么？依我看，其实质也没有什么太大的区别。区别在于计算的方向。

编写递归算法的时候，我们把当前问题的上下文保存在栈里，然后命令计算机直接用同样的方法求解稍小规模的子问题（递归调用），以此类推直到问题被分解到最最平凡的时候，直接返回最小问题的解，然后从栈里取出保存的上下文，逐层向上返回，直到最外层就得到了解。

而动态规划算法，则一般是将这个过程倒过来，首先求解最平凡的问题，然后利用归纳好的状态转移，逐步扩大问题的规模，形成更大规模问题的解，直到达到问题要求的规模为止。这中间可能需要记录下来早期所有更小规模问题的解。

[![](https://sexywp.com/wp-content/uploads/2021/03/recursion-vs-dp-1024x534.png)](https://sexywp.com/wp-content/uploads/2021/03/recursion-vs-dp.png)

递归和动态规划在计算方向上的区别

两者的差别在于，动态规划问题，总是可以编写出对应的递归算法，但是递归算法，不一定可以写出其动态规划解法，或者说，递归算法去编写出其动态规划解法，不一定有意义。

这里的核心问题，在于动态规划是否可以提高整个算法的效率，降低复杂度，在上面的图中，我们看到，在递归计算过程中，fib(3) 这个子树，被反复求解，浪费了计算的时间。但是在有些场景中，并不存在这种重复现象。比如，求解“八皇后问题”的递归解法（其本质是个回溯法）。

### 适合用动态规划求解的特征

无数前辈通过不断的实践和积累，给我们总结了适合使用动态规划求解的问题的三个典型特征：

1.  重叠子问题：原问题被分解后，计算过程中是有重叠部分的，我们可以把重叠部分的计算给节省掉，比如，上面 fib 数列求解，反复求解了 fib(3)。我们可以反过来看一个没有重叠子问题的例子，比如使用“分治法”的时候，在归并排序的时候，我们把整个集合，分成了两份，对这两份分别排序，再合并结果。也是把一个大的问题，分解为两个性质一样的子问题，但是这两个问题并没有重叠的部分；
2.  最优子结构：原问题由一系列子问题构成（这些子问题可能是嵌套的，见上面），每个子问题的最优解，就恰恰是原问题的解，或者反过来说，原问题可能就是一系列子问题里，最大的一个子问题的，这种规律叫最优子结构，参考上面的插图，感受与贪心法区别；
3.  无后效性：这可能是最最难以把握的一点，讲的其实就是前述子问题的解，不影响后续或者更大规模子问题的解的选择空间，也看到一些对动态规划的阐述，没有“无后效性”这一条件，实际解题的时候，也会发现有些问题的拆解上有些技巧，就是你要故意将问题拆解成无后效性的一系列子问题，所以，这一条也可以看成是一种手段，和上面两条并非完全正交，所以有些讲解，也会不提这一条，不过如果一个问题很难被拆解成无后效性的子问题，那么你可能就要警惕，或许，这题不应该用动态规划来解。

## 进阶篇

介绍动态规划有哪些典型的套路，这些套路的解法是什么？动态规划的思想是怎么在这些经典套路里应用的？

上面基础篇，其实就是劝退众多算法学习者的，因为太枯燥，太抽象，看完了好像明白了，也还是完全不会做题，或者根本就看不明白。实际学习下来的体验也是，从实践中学，似乎才是最好的办法，只有自己撞到头破血流，然后知道痛了，才会发现，有些基本的道理其实前人早就想明白了。当然，自己能想出来最好，想不出来也不用太过自卑，大部分人都和你一样，根本想不出来，但是他们掌握了如何运用这些道理的技巧，也是一样可以解题的。

### 背包问题

背包问题经常是讲解动态规划最为经典的问题，也叫 0/1 背包问题，英文是 Knapsack Problem，这个问题的研究是如此经典，人类对这个问题的研究已经持续了一个世纪，最早可以追溯到 1897 年（参见维基百科）。

问题描述是这样的，有一个双肩包，能承载的最大重量是 W 千克，现在有 n 个物品，每个物品 i 的重量是 wi 千克，价值是 vi，问，在不超过重量 W 的情况下，背包最多能装的物品总价值是多少？问题里提到的物品，每个只有一件，可以放入背包，或者不放入背包，如果不放入背包用 0 表示，放入背包用 1 表示，也就是计算每个物品在放入这个决策上的 0/1 取值问题。所以，这个问题被称为 0/1 背包问题。

这个问题如果穷举的话，尝试每个物品放入，或者不放入两种情况，那么问题空间有 2n ，这是一个指数级的规模，只要 n 稍微大一点，就不可能在短时间求解出来。可能，这就是这个问题如此典型，以至于所有讲动态规划都要用这个问题来讲解的原因吧。

这个问题是有朴素的递归解法的，我们可以尝试去缩小问题的规模，比如，我们只考虑 n - 1 个物品，现在假设，我们已经可以求出某个 W 大小的背包内，放入 n - 1 个物品的最大总价值 Vn-1，然后，开始考虑如何处理最后一个物品，有两种情况：一种情况就是最后一个物品不放入，那么，Vn-1 就是 W 背包，放入 n 个物品的最大值；另一种情况，就是必须要放入最后一个物品，假设其重量是 wn，如果必须放入，那么背包就必须空出这个重量来，所以，相当于是在容纳重量为 W - wn 的背包内，放入 n - 1 个物品的最大总价值，我们可以称为 V'n-1，的基础上，再加上 vn，成为 V'n-1 + vn。这两种情况里，较大的那个，就是最终的解。

```python
obj = collections.namedtuple('obj', ['w', 'v'])

def knapsack(W: int, items: List[obj]) -> int:
    if W <= 0:
        return 0
    
    n = len(items)
    if n == 0:
        return 0

    putoutMax = knapsack(W, items[:n - 1])
    putinMax  = knapsack(W - items[n - 1].w, items[:n - 1]) + items[n - 1].v
    return max(putoutMax, putinMax)
```

上面给出伪代码，这个计算方法，可以将问题规约为规模更小的两个子问题，分别求解后，再得到最终的解。这个递归解法的时间复杂度是多少呢？咱们这样思考，每 1 个问题被分解为 2 个子问题分别求解，所以，递归每深入一层，子问题数量就多 1 倍。那么子问题到底有多少层呢？我们可以看到，每深入 1 层，物品就减少 1 个，假如，W 空间足够大，那么显然需要递归 n 层，每个子问题，通过 2 个操作（一次求和以及一次 max 函数）合并结果，所以最坏情况，总共执行 2 × ( 1 + 2 + ... + 2n-1) 次操作，所以，时间复杂度还是 O(2n) 。仍然是指数级的。

不过，如果画出这个递归过程的树形调用结构，我们就会发现，这里有大量的重叠子问题，如果我们使用一个缓存，记住所有重叠子问题的解，那么就可以大量节省计算时间。这个缓存怎么设计呢？你会发现，其实每个子问题，其实只有两个变量，就是 W 总容量，以及需要尝试放入的物品 n 个，只需要 W×n 个整数，就可以保存所有可能出现的子问题的解了。这时候，我们不免想到，总共的子问题可能取值就 W× n 个，但是为什么问题搜索空间却成了 2n 个？如果，我们直接把 W×n 个可能的取值，都给求出来，问题其实就解决了。

到这里，其实就推导出了背包问题的动态规划解法。我们需要遍历的空间就是 W×n，我们从最平凡的问题入手，背包空间为 0，或者物品数量为 0 开始，其答案是显而易见的。然后，逐个求出每个组合的解。我们把一对儿 (W, n) 称为这个问题的一个状态，状态与状态之间的关联关系，称为状态转移方程（函数），利用这个关系，就可以编写出动态规划解法。

```python
def knapsack(W: int, items: List[obj]) -> int:
    n = len(items)
    dp = int[W][n]
    
    init(dp, 0)
    
    for w in range(2, W):
        for i in range(2, n):
            if items[i].w < w:
                dp[w][i] = max(dp[w - items[i].w][i - 1], dp[w][i - 1])
            else:
                dp[w][i] = dp[w][i - 1]
    return dp[W][n]
```

上面给出了伪代码（注意这是伪代码，不是 Python，无法运行的），从前面的递归解法中，其实，已经显示出了状态与状态之间的递推关系，当我们从最平凡的 0 开始顺序求解状态时候，就比较容易逐步利用前面已经求解好的值，去递推后面的值，这个方法也可以称为递推法，递推是动态规划里，比较常见的一种情况。上面，是从 0 开始，向更大规模的问题去推导，叫“顺推”，也可以从最终结局开始，往一开始的方向去推导，叫“逆推”。

### 子数组问题

子数组问题，也是一个经典的“可能”可以运用动态规划思想解题的题目类型。所谓子数组，核心特性是在一个线性的数据结构上（可以随机访问），在一个“连续”的区间内，求某种最优化结果。比如，有一道经典的题目是，最长回文子串，字符串可以看作是字符的数组，回文子串就是满足倒序后仍然与原来相等的字符串。此外，还有一些题目，比如，求子数组的最大和，最大乘积，也属于这类题目。

### 子序列问题

与子数组问题不同，子序列一类问题，则只对每个元素的“顺序”有要求，但是不要求“连续”。其他方面要求，跟子数组类的问题差不多。经典例题有：求最长递增/递减子序列，也可以求最长回文子序列等等。

## 实战篇

举一反三地利用动态规划来进行解题，各种各样的变体，例题等。通过列举各种各样的例题，一次性掌握动态规划。

## 总结篇

个人学习心得和总结，自我水平的评估，学习过程中的注意点。